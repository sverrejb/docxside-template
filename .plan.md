# Plan: Make `save()` work

## What needs to happen

The generated `save()` method should:
1. Open the template .docx (a zip archive)
2. Create a new .docx at the output path
3. Copy every file from the template into the output, replacing placeholders in XML files
4. Finalize the zip

## Two problems to fix

### Problem 1: Zip writing (straightforward)
The current code reads files from the archive but never writes them to `zip_writer` and never calls `finish()`. Fix:
- After reading (and optionally modifying) each file's contents, call `zip_writer.start_file(file_name, SimpleFileOptions::default())` then `zip_writer.write_all(&contents)`
- Call `zip_writer.finish()` after the loop
- Remove debug `println!` statements
- Also do replacement on `.xml.rels` files (they're XML too)

### Problem 2: Placeholder replacement (the real issue)
Word splits text across multiple XML runs. In `HelloWorld.docx`, `{ firstName }` becomes:
```xml
<w:t xml:space="preserve">{ </w:t>
...
<w:t>firstName</w:t>
...
<w:t xml:space="preserve"> }! This is a test</w:t>
```

A simple `String::replace("{ firstName }", "Sverre")` on the raw XML won't match.

**Proposed approach**: For each XML file, use a regex to collect all `<w:t>` text content with their byte positions, concatenate the text, find placeholder matches in the concatenated text, then map those matches back to the `<w:t>` elements and rewrite them. This handles the run-splitting problem.

This logic is too complex to inline in the generated code via `quote!`. Instead, I'll add a **runtime helper function** to the library that the generated `save()` calls. The proc-macro crate can re-export it since test-crate already depends on `docxide-templates`.

Wait — this is a proc-macro crate, so it can't export runtime items. I'll need to either:
- **(A)** Split into two crates: a proc-macro crate + a runtime crate
- **(B)** Put the replacement logic inline in the generated code via `quote!`
- **(C)** Keep it simple for now: do raw string replace (works when Word doesn't split runs), and document the limitation

**Recommended: (B)** — generate a private helper function alongside each struct that does the XML-aware replacement. The function uses only `std` (regex on raw XML with a small pattern). This keeps it as a single crate.

Actually, simplest viable version of (B): generate code that uses a regex to strip XML tags between parts of a `<w:t>` run boundary, collects the text, does replacement, and writes it back. But regex is a heavy dep to require in downstream crates.

**Revised approach**: For each XML string, iterate through `<w:t>` elements, collect their text + positions, concatenate, find placeholders, then splice replacements back into the XML at the right byte offsets. This only needs `std`. Generate this as a closure/helper in the `save()` body.

## Implementation steps

1. Update `generate_save_body` to:
   - Write each (possibly modified) file to the zip writer via `start_file` + `write_all`
   - Call `finish()` on the zip writer
   - Remove debug println
2. Replace the naive `String::replace` with XML-aware `<w:t>` replacement logic
3. Update test-crate to call `save()` and verify the output
